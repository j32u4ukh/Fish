# Fish
建立自己的網路框架 by numpy -> 或許可以改成以"演化算法"搭架而成的網路架構，組合和拆分都變得更簡單，也由於都是 numpy，運算到一半想要在而外對數列做操作也可以。

應該擁有以下特性：
* 基因長度差異不大時，還是可以交配
* 以 0 / 1 為基因的呈現方式，再轉譯成需要的樣子
* 0 / 1 形成的超長數列，個數不一定多少個，但相近物種的前 N 個數值差異程度不應該太大
* 基本運算就像 CNN 的卷積層一樣，但採用點乘。
* 上述的卷積效果會使得矩陣個數增加，應有其他類型細胞是會減少矩陣數量的。
* 參數越多，需要越多能量；表現越好，可獲得越多能量；總能量根據名次去分配給不同生命；獲得的能量扣除消耗的能量，為剩餘能量，該能量越多，交配機會越多。

### 第一部分

* 1-1 [多少個 0 / 1 來轉換成十進位的數值](事先定義上下限) -> 計算出後續定義一個細胞所需基因個數 & 最多可定義多少基因
* 1-2 [矩陣類型(1)][矩陣長寬(2)]...[矩陣類型(1)][矩陣長寬(2)] -> n 個細胞
* 若卷積的產出長寬各為 3 個，長寬至少等於卷積長寬 + 2(為了長寬各 3 個 sliding window)，不然會填充至此大小。當長寬小於各自長度的 3 被以下時，會自動計算 stride。因此，當 stride 大於的卷積長寬時，會採用第 3 種策略，即 OpenEyes 模仿視覺的方式。

### 第二部分

* [細胞結構如何連結(n * n)]
* 根據細胞間不同連結方式，會有一波一波的輸出，後面的輸出可能再往回傳成為下一波的輸入。
* 或許需要排除細胞間循環傳播，沒有輸出或輸入值；也有可能它會自己被淘汰。
* 細胞區域間貢獻越多，連結越多越粗。

### 第三部分

* 每一個細胞應有結構：[卷積長寬分別的產出個數(2)/多少張矩陣壓縮成一張(1)][矩陣內數值()]
* 矩陣數值的定義(採用 sliding window 的形式來取值，例: 10011 -> 1001, 0011，可有效減少所需基因個數)
* 卷積的產出個數由基因定義長寬方向個數 X 面對不同大小的輸入矩陣
* decimal = int(str("1000101001"), 2)，Python 有內建的二進位轉十進位
* 應有一部份基因用於定義細胞類型，以添加不同的視覺模仿類型、不同的激活函數。
